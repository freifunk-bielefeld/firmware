From a9a23332273142176e97f33035a3d4b08805a191 Mon Sep 17 00:00:00 2001
From: Moritz Warning <moritzwarning@web.de>
Date: Tue, 1 Nov 2016 01:56:36 +0100
Subject: [PATCH 1/6] batman-adv: update to 2016.4

---
 batman-adv/Config.in                               |   5 +
 batman-adv/Makefile                                |  22 +-
 batman-adv/files/compat-hacks.h                    | 113 ++++++++
 ...make-sure-ELP-OGM-orig-MAC-is-updated-on-.patch |  64 -----
 ...-adv-Avoid-duplicate-neigh_node-additions.patch |  89 -------
 ...Avoid-nullptr-derefence-in-batadv_v_neigh.patch |  38 ---
 ...an-adv-Fix-refcnt-leak-in-batadv_v_neigh_.patch |  81 ------
 ...Fix-double-neigh_node_put-in-batadv_v_ogm.patch |  40 ---
 ...initialize-ELP-orig-address-on-secondary-.patch | 110 --------
 ...Add-missing-include-for-batadv_v_neigh_is.patch |  28 --
 .../0008-batman-adv-fix-skb-deref-after-free.patch |  46 ----
 ...replace-WARN-with-rate-limited-output-on-.patch |  40 ---
 ...Fix-build-against-recent-Debian-Stretch-k.patch |  58 ----
 ...Clean-up-untagged-vlan-when-destroying-vi.patch |  45 ----
 ...Fix-ICMP-RR-ethernet-access-after-skb_lin.patch |  31 ---
 ...-batman-adv-Fix-double-put-of-vlan-object.patch |  32 ---
 ...Fix-use-after-free-double-free-of-tt_req_.patch | 172 ------------
 ...Avoid-nullptr-dereference-in-bla-after-vl.patch |  35 ---
 ...Avoid-nullptr-dereference-in-dat-after-vl.patch |  49 ----
 ...Avoid-tt_req_node-list-put-for-unhashed-e.patch |  41 ---
 ...Fix-orig_node_vlan-leak-on-orig_node_rele.patch |  43 ---
 ...Fix-non-atomic-bla_claim-backbone_gw-acce.patch | 291 ---------------------
 ...-Fix-reference-leak-in-batadv_find_router.patch | 120 ---------
 ...Free-last_bonding_candidate-on-release-of.patch |  45 ----
 ...dv-Fix-speedy-join-in-gateway-client-mode.patch |  35 ---
 25 files changed, 132 insertions(+), 1541 deletions(-)
 delete mode 100644 batman-adv/patches/0001-batman-adv-make-sure-ELP-OGM-orig-MAC-is-updated-on-.patch
 delete mode 100644 batman-adv/patches/0002-batman-adv-Avoid-duplicate-neigh_node-additions.patch
 delete mode 100644 batman-adv/patches/0003-batman-adv-Avoid-nullptr-derefence-in-batadv_v_neigh.patch
 delete mode 100644 batman-adv/patches/0004-batman-adv-Fix-refcnt-leak-in-batadv_v_neigh_.patch
 delete mode 100644 batman-adv/patches/0005-batman-adv-Fix-double-neigh_node_put-in-batadv_v_ogm.patch
 delete mode 100644 batman-adv/patches/0006-batman-adv-initialize-ELP-orig-address-on-secondary-.patch
 delete mode 100644 batman-adv/patches/0007-batman-adv-Add-missing-include-for-batadv_v_neigh_is.patch
 delete mode 100644 batman-adv/patches/0008-batman-adv-fix-skb-deref-after-free.patch
 delete mode 100644 batman-adv/patches/0009-batman-adv-replace-WARN-with-rate-limited-output-on-.patch
 delete mode 100644 batman-adv/patches/0010-batman-adv-Fix-build-against-recent-Debian-Stretch-k.patch
 delete mode 100644 batman-adv/patches/0011-batman-adv-Clean-up-untagged-vlan-when-destroying-vi.patch
 delete mode 100644 batman-adv/patches/0012-batman-adv-Fix-ICMP-RR-ethernet-access-after-skb_lin.patch
 delete mode 100644 batman-adv/patches/0013-batman-adv-Fix-double-put-of-vlan-object.patch
 delete mode 100644 batman-adv/patches/0014-batman-adv-Fix-use-after-free-double-free-of-tt_req_.patch
 delete mode 100644 batman-adv/patches/0015-batman-adv-Avoid-nullptr-dereference-in-bla-after-vl.patch
 delete mode 100644 batman-adv/patches/0016-batman-adv-Avoid-nullptr-dereference-in-dat-after-vl.patch
 delete mode 100644 batman-adv/patches/0017-batman-adv-Avoid-tt_req_node-list-put-for-unhashed-e.patch
 delete mode 100644 batman-adv/patches/0018-batman-adv-Fix-orig_node_vlan-leak-on-orig_node_rele.patch
 delete mode 100644 batman-adv/patches/0019-batman-adv-Fix-non-atomic-bla_claim-backbone_gw-acce.patch
 delete mode 100644 batman-adv/patches/0020-batman-adv-Fix-reference-leak-in-batadv_find_router.patch
 delete mode 100644 batman-adv/patches/0021-batman-adv-Free-last_bonding_candidate-on-release-of.patch
 delete mode 100644 batman-adv/patches/0022-batman-adv-Fix-speedy-join-in-gateway-client-mode.patch

diff --git a/batman-adv/Config.in b/batman-adv/Config.in
index 48092e7..8c75f31 100644
--- a/batman-adv/Config.in
+++ b/batman-adv/Config.in
@@ -14,6 +14,11 @@ config KMOD_BATMAN_ADV_DAT
 	depends on PACKAGE_kmod-batman-adv
 	default y
 
+config KMOD_BATMAN_ADV_DEBUGFS
+	bool "enable debugfs support"
+	depends on PACKAGE_kmod-batman-adv
+	default y
+
 config KMOD_BATMAN_ADV_MCAST
 	bool "enable multicast transmission optimization"
 	depends on PACKAGE_kmod-batman-adv
diff --git a/batman-adv/Makefile b/batman-adv/Makefile
index e8334d5..23b2f74 100644
--- a/batman-adv/Makefile
+++ b/batman-adv/Makefile
@@ -10,9 +10,9 @@ include $(TOPDIR)/rules.mk
 
 PKG_NAME:=batman-adv
 
-PKG_VERSION:=2016.1
-PKG_RELEASE:=3
-PKG_MD5SUM:=8c8e449009b4d29512d26ee308960bb5
+PKG_VERSION:=2016.4
+PKG_RELEASE:=0
+PKG_MD5SUM:=1ed28d02ad86050d1518023e354737b6
 
 PKG_SOURCE:=$(PKG_NAME)-$(PKG_VERSION).tar.gz
 PKG_SOURCE_URL:=https://downloads.open-mesh.org/batman/releases/batman-adv-$(PKG_VERSION)
@@ -50,6 +50,7 @@ endef
 PKG_EXTRA_KCONFIG:= \
 	CONFIG_BATMAN_ADV=m \
 	CONFIG_BATMAN_ADV_DEBUG=$(if $(CONFIG_KMOD_BATMAN_ADV_DEBUG_LOG),y,n) \
+	CONFIG_BATMAN_ADV_DEBUGFS=$(if $(CONFIG_KMOD_BATMAN_ADV_DEBUGFS),y,n) \
 	CONFIG_BATMAN_ADV_BLA=$(if $(CONFIG_KMOD_BATMAN_ADV_BLA),y,n) \
 	CONFIG_BATMAN_ADV_DAT=$(if $(CONFIG_KMOD_BATMAN_ADV_DAT),y,n) \
 	CONFIG_BATMAN_ADV_MCAST=$(if $(CONFIG_KMOD_BATMAN_ADV_MCAST),y,n) \
@@ -62,15 +63,22 @@ PKG_EXTRA_CFLAGS:= \
 
 NOSTDINC_FLAGS = \
 	-I$(PKG_BUILD_DIR)/net/batman-adv \
-	-I$(STAGING_DIR)/usr/include/mac80211-backport/uapi \
 	-I$(STAGING_DIR)/usr/include/mac80211-backport \
-	-I$(STAGING_DIR)/usr/include/mac80211/uapi \
+	-I$(STAGING_DIR)/usr/include/mac80211-backport/uapi \
 	-I$(STAGING_DIR)/usr/include/mac80211 \
+	-I$(STAGING_DIR)/usr/include/mac80211/uapi \
+	-I$(PKG_BUILD_DIR)/include/ \
 	-include backport/backport.h \
 	-include $(PKG_BUILD_DIR)/compat-hacks.h
 
+COMPAT_SOURCES = \
+	$(if $(CONFIG_KMOD_BATMAN_ADV_MCAST),../../compat-sources/net/core/skbuff.o,) \
+	$(if $(CONFIG_KMOD_BATMAN_ADV_MCAST),../../compat-sources/net/ipv4/igmp.o,) \
+	$(if $(CONFIG_KMOD_BATMAN_ADV_MCAST),../../compat-sources/net/ipv6/mcast_snoop.o,) \
+
 define Build/Compile
-	+$(MAKE) $(PKG_JOBS) -C "$(LINUX_DIR)" \
+	+env "batman-adv-y=$(COMPAT_SOURCES)" \
+	$(MAKE) $(PKG_JOBS) -C "$(LINUX_DIR)" \
 		ARCH="$(LINUX_KARCH)" \
 		CROSS_COMPILE="$(TARGET_CROSS)" \
 		SUBDIRS="$(PKG_BUILD_DIR)/net/batman-adv" \
@@ -83,8 +91,6 @@ endef
 define Build/Prepare
 	$(call Build/Prepare/Default)
 	$(CP) ./files/compat-hacks.h $(PKG_BUILD_DIR)/
-	$(SED) '/#define _NET_BATMAN_ADV_MAIN_H_/a\#undef CONFIG_MODULE_STRIPPED' \
-		$(PKG_BUILD_DIR)/net/batman-adv/main.h
 endef
 
 define Build/Clean
diff --git a/batman-adv/files/compat-hacks.h b/batman-adv/files/compat-hacks.h
index 5126fc2..32903b5 100644
--- a/batman-adv/files/compat-hacks.h
+++ b/batman-adv/files/compat-hacks.h
@@ -1,5 +1,7 @@
 /* Please avoid adding hacks here - instead add it to mac80211/backports.git */
 
+#undef CONFIG_MODULE_STRIPPED
+
 #include <linux/version.h>	/* LINUX_VERSION_CODE */
 #include <linux/types.h>
 
@@ -31,6 +33,17 @@
 
 #endif /* < KERNEL_VERSION(4, 5, 0) */
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 2, 0)
+
+struct sk_buff *skb_checksum_trimmed(struct sk_buff *skb,
+				     unsigned int transport_len,
+				     __sum16(*skb_chkf)(struct sk_buff *skb));
+
+int ip_mc_check_igmp(struct sk_buff *skb, struct sk_buff **skb_trimmed);
+
+int ipv6_mc_check_mld(struct sk_buff *skb, struct sk_buff **skb_trimmed);
+
+#endif /* < KERNEL_VERSION(4, 2, 0) */
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(4, 3, 0)
 
@@ -74,3 +87,103 @@ batadv_ethtool_get_link_ksettings(struct net_device *dev,
 }
 
 #endif /* < KERNEL_VERSION(4, 6, 0) */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 7, 0)
+
+#define netif_trans_update batadv_netif_trans_update
+static inline void batadv_netif_trans_update(struct net_device *dev)
+{
+	dev->trans_start = jiffies;
+}
+
+#endif /* < KERNEL_VERSION(4, 7, 0) */
+
+
+#include_next <linux/netlink.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 7, 0)
+
+#include_next <net/netlink.h>
+
+static inline bool batadv_nla_need_padding_for_64bit(struct sk_buff *skb);
+
+static inline int batadv_nla_align_64bit(struct sk_buff *skb, int padattr)
+{
+	if (batadv_nla_need_padding_for_64bit(skb) &&
+	    !nla_reserve(skb, padattr, 0))
+		return -EMSGSIZE;
+
+	return 0;
+}
+
+static inline struct nlattr *batadv__nla_reserve_64bit(struct sk_buff *skb,
+						       int attrtype,
+						       int attrlen, int padattr)
+{
+	if (batadv_nla_need_padding_for_64bit(skb))
+		batadv_nla_align_64bit(skb, padattr);
+
+	return __nla_reserve(skb, attrtype, attrlen);
+}
+
+static inline void batadv__nla_put_64bit(struct sk_buff *skb, int attrtype,
+					 int attrlen, const void *data,
+					 int padattr)
+{
+	struct nlattr *nla;
+
+	nla = batadv__nla_reserve_64bit(skb, attrtype, attrlen, padattr);
+	memcpy(nla_data(nla), data, attrlen);
+}
+
+static inline bool batadv_nla_need_padding_for_64bit(struct sk_buff *skb)
+{
+#ifndef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS
+	/* The nlattr header is 4 bytes in size, that's why we test
+	 * if the skb->data _is_ aligned.  A NOP attribute, plus
+	 * nlattr header for next attribute, will make nla_data()
+	 * 8-byte aligned.
+	 */
+	if (IS_ALIGNED((unsigned long)skb_tail_pointer(skb), 8))
+		return true;
+#endif
+	return false;
+}
+
+static inline int batadv_nla_total_size_64bit(int payload)
+{
+	return NLA_ALIGN(nla_attr_size(payload))
+#ifndef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS
+		+ NLA_ALIGN(nla_attr_size(0))
+#endif
+		;
+}
+
+static inline int batadv_nla_put_64bit(struct sk_buff *skb, int attrtype,
+				       int attrlen, const void *data,
+				       int padattr)
+{
+	size_t len;
+
+	if (batadv_nla_need_padding_for_64bit(skb))
+		len = batadv_nla_total_size_64bit(attrlen);
+	else
+		len = nla_total_size(attrlen);
+	if (unlikely(skb_tailroom(skb) < len))
+		return -EMSGSIZE;
+
+	batadv__nla_put_64bit(skb, attrtype, attrlen, data, padattr);
+	return 0;
+}
+
+#define nla_put_u64_64bit(_skb, _attrtype, _value, _padattr) \
+	batadv_nla_put_u64_64bit(_skb, _attrtype, _value, _padattr)
+static inline int batadv_nla_put_u64_64bit(struct sk_buff *skb, int attrtype,
+					   u64 value, int padattr)
+{
+	return batadv_nla_put_64bit(skb, attrtype, sizeof(u64), &value,
+				    padattr);
+}
+
+#endif /* < KERNEL_VERSION(4, 7, 0) */
+
diff --git a/batman-adv/patches/0001-batman-adv-make-sure-ELP-OGM-orig-MAC-is-updated-on-.patch b/batman-adv/patches/0001-batman-adv-make-sure-ELP-OGM-orig-MAC-is-updated-on-.patch
deleted file mode 100644
index 70adb91..0000000
--- a/batman-adv/patches/0001-batman-adv-make-sure-ELP-OGM-orig-MAC-is-updated-on-.patch
+++ /dev/null
@@ -1,64 +0,0 @@
-From a636bf0b69010222ea58337d425ca9ff8ce52639 Mon Sep 17 00:00:00 2001
-From: Antonio Quartulli <a@unstable.cc>
-Date: Mon, 2 May 2016 18:27:38 +0800
-Subject: [PATCH 1/6] batman-adv: make sure ELP/OGM orig MAC is updated on
- address change
-
-When the MAC address of the primary interface is changed,
-update the originator address in the ELP and OGM skb buffers as
-well in order to reflect the change.
-
-Fixes: a4b88af77e28 ("batman-adv: ELP - adding basic infrastructure")
-Reported-by: Marek Lindner <marek@neomailbox.ch>
-Signed-off-by: Antonio Quartulli <a@unstable.cc>
-Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
----
- net/batman-adv/bat_v.c | 26 ++++++++++++++++++++++----
- 1 file changed, 22 insertions(+), 4 deletions(-)
-
-diff --git a/net/batman-adv/bat_v.c b/net/batman-adv/bat_v.c
-index 4026f19..4547fce 100644
---- a/net/batman-adv/bat_v.c
-+++ b/net/batman-adv/bat_v.c
-@@ -72,16 +72,34 @@ static void batadv_v_iface_disable(struct batadv_hard_iface *hard_iface)
- 	batadv_v_elp_iface_disable(hard_iface);
- }
- 
--static void batadv_v_iface_update_mac(struct batadv_hard_iface *hard_iface)
--{
--}
--
- static void batadv_v_primary_iface_set(struct batadv_hard_iface *hard_iface)
- {
- 	batadv_v_elp_primary_iface_set(hard_iface);
- 	batadv_v_ogm_primary_iface_set(hard_iface);
- }
- 
-+/**
-+ * batadv_v_iface_update_mac - react to hard-interface MAC address change
-+ * @hard_iface: the modified interface
-+ *
-+ * If the modified interface is the primary one, update the originator
-+ * address in the ELP and OGM messages to reflect the new MAC address.
-+ */
-+static void batadv_v_iface_update_mac(struct batadv_hard_iface *hard_iface)
-+{
-+	struct batadv_priv *bat_priv = netdev_priv(hard_iface->soft_iface);
-+	struct batadv_hard_iface *primary_if;
-+
-+	primary_if = batadv_primary_if_get_selected(bat_priv);
-+	if (primary_if != hard_iface)
-+		goto out;
-+
-+	batadv_v_primary_iface_set(hard_iface);
-+out:
-+	if (primary_if)
-+		batadv_hardif_put(primary_if);
-+}
-+
- static void
- batadv_v_hardif_neigh_init(struct batadv_hardif_neigh_node *hardif_neigh)
- {
--- 
-2.8.0.rc3
-
diff --git a/batman-adv/patches/0002-batman-adv-Avoid-duplicate-neigh_node-additions.patch b/batman-adv/patches/0002-batman-adv-Avoid-duplicate-neigh_node-additions.patch
deleted file mode 100644
index ea191b3..0000000
--- a/batman-adv/patches/0002-batman-adv-Avoid-duplicate-neigh_node-additions.patch
+++ /dev/null
@@ -1,89 +0,0 @@
-From 8013ae257447c99d7ba037967458f91ceb4051ae Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Linus=20L=C3=BCssing?= <linus.luessing@c0d3.blue>
-Date: Thu, 7 Jan 2016 08:11:12 +0100
-Subject: [PATCH 2/6] batman-adv: Avoid duplicate neigh_node additions
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Two parallel calls to batadv_neigh_node_new() might race for creating
-and adding the same neig_node. Fix this by including the check for any
-already existing, identical neigh_node within the spin-lock.
-
-This fixes splats like the following:
-
-[  739.535069] ------------[ cut here ]------------
-[  739.535079] WARNING: CPU: 0 PID: 0 at /usr/src/batman-adv/git/batman-adv/net/batman-adv/bat_iv_ogm.c:1004 batadv_iv_ogm_process_per_outif+0xe3f/0xe60 [batman_adv]()
-[  739.535092] too many matching neigh_nodes
-[  739.535094] Modules linked in: dm_mod tun ip6table_filter ip6table_mangle ip6table_nat nf_nat_ipv6 ip6_tables xt_nat iptable_nat nf_nat_ipv4 nf_nat xt_TCPMSS xt_mark iptable_mangle xt_tcpudp xt_conntrack iptable_filter ip_tables x_tables ip_gre ip_tunnel gre bridge stp llc thermal_sys kvm_intel kvm crct10dif_pclmul crc32_pclmul sha256_ssse3 sha256_generic hmac drbg ansi_cprng aesni_intel aes_x86_64 lrw gf128mul glue_helper ablk_helper cryptd evdev pcspkr ip6_gre ip6_tunnel tunnel6 batman_adv(O) libcrc32c nf_conntrack_ipv6 nf_defrag_ipv6 nf_conntrack_ipv4 nf_defrag_ipv4 nf_conntrack autofs4 ext4 crc16 mbcache jbd2 xen_netfront xen_blkfront crc32c_intel
-[  739.535177] CPU: 0 PID: 0 Comm: swapper/0 Tainted: G        W  O    4.2.0-0.bpo.1-amd64 #1 Debian 4.2.6-3~bpo8+2
-[  739.535186]  0000000000000000 ffffffffa013b050 ffffffff81554521 ffff88007d003c18
-[  739.535201]  ffffffff8106fa01 0000000000000000 ffff8800047a087a ffff880079c3a000
-[  739.735602]  ffff88007b82bf40 ffff88007bc2d1c0 ffffffff8106fa7a ffffffffa013aa8e
-[  739.735624] Call Trace:
-[  739.735639]  <IRQ>  [<ffffffff81554521>] ? dump_stack+0x40/0x50
-[  739.735677]  [<ffffffff8106fa01>] ? warn_slowpath_common+0x81/0xb0
-[  739.735692]  [<ffffffff8106fa7a>] ? warn_slowpath_fmt+0x4a/0x50
-[  739.735715]  [<ffffffffa012448f>] ? batadv_iv_ogm_process_per_outif+0xe3f/0xe60 [batman_adv]
-[  739.735740]  [<ffffffffa0124813>] ? batadv_iv_ogm_receive+0x363/0x380 [batman_adv]
-[  739.735762]  [<ffffffffa0124813>] ? batadv_iv_ogm_receive+0x363/0x380 [batman_adv]
-[  739.735783]  [<ffffffff810b0841>] ? __raw_callee_save___pv_queued_spin_unlock+0x11/0x20
-[  739.735804]  [<ffffffffa012cb39>] ? batadv_batman_skb_recv+0xc9/0x110 [batman_adv]
-[  739.735825]  [<ffffffff81464891>] ? __netif_receive_skb_core+0x841/0x9a0
-[  739.735838]  [<ffffffff810b0841>] ? __raw_callee_save___pv_queued_spin_unlock+0x11/0x20
-[  739.735853]  [<ffffffff81465681>] ? process_backlog+0xa1/0x140
-[  739.735864]  [<ffffffff81464f1a>] ? net_rx_action+0x20a/0x320
-[  739.735878]  [<ffffffff81073aa7>] ? __do_softirq+0x107/0x270
-[  739.735891]  [<ffffffff81073d82>] ? irq_exit+0x92/0xa0
-[  739.735905]  [<ffffffff8137e0d1>] ? xen_evtchn_do_upcall+0x31/0x40
-[  739.735924]  [<ffffffff8155b8fe>] ? xen_do_hypervisor_callback+0x1e/0x40
-[  739.735939]  <EOI>  [<ffffffff810013aa>] ? xen_hypercall_sched_op+0xa/0x20
-[  739.735965]  [<ffffffff810013aa>] ? xen_hypercall_sched_op+0xa/0x20
-[  739.735979]  [<ffffffff8100a39c>] ? xen_safe_halt+0xc/0x20
-[  739.735991]  [<ffffffff8101da6c>] ? default_idle+0x1c/0xa0
-[  739.736004]  [<ffffffff810abf6b>] ? cpu_startup_entry+0x2eb/0x350
-[  739.736019]  [<ffffffff81b2af5e>] ? start_kernel+0x480/0x48b
-[  739.736032]  [<ffffffff81b2d116>] ? xen_start_kernel+0x507/0x511
-[  739.736048] ---[ end trace c106bb901244bc8c ]---
-
-Reported-by: Martin Weinelt <martin@darmstadt.freifunk.net>
-Signed-off-by: Linus LÃ¼ssing <linus.luessing@c0d3.blue>
-Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
----
- net/batman-adv/originator.c | 6 ++++--
- 1 file changed, 4 insertions(+), 2 deletions(-)
-
-diff --git a/net/batman-adv/originator.c b/net/batman-adv/originator.c
-index c355a82..28241a4 100644
---- a/net/batman-adv/originator.c
-+++ b/net/batman-adv/originator.c
-@@ -630,6 +630,8 @@ batadv_neigh_node_new(struct batadv_orig_node *orig_node,
- 	struct batadv_neigh_node *neigh_node;
- 	struct batadv_hardif_neigh_node *hardif_neigh = NULL;
- 
-+	spin_lock_bh(&orig_node->neigh_list_lock);
-+
- 	neigh_node = batadv_neigh_node_get(orig_node, hard_iface, neigh_addr);
- 	if (neigh_node)
- 		goto out;
-@@ -666,15 +668,15 @@ batadv_neigh_node_new(struct batadv_orig_node *orig_node,
- 	kref_init(&neigh_node->refcount);
- 	kref_get(&neigh_node->refcount);
- 
--	spin_lock_bh(&orig_node->neigh_list_lock);
- 	hlist_add_head_rcu(&neigh_node->list, &orig_node->neigh_list);
--	spin_unlock_bh(&orig_node->neigh_list_lock);
- 
- 	batadv_dbg(BATADV_DBG_BATMAN, orig_node->bat_priv,
- 		   "Creating new neighbor %pM for orig_node %pM on interface %s\n",
- 		   neigh_addr, orig_node->orig, hard_iface->net_dev->name);
- 
- out:
-+	spin_unlock_bh(&orig_node->neigh_list_lock);
-+
- 	if (hardif_neigh)
- 		batadv_hardif_neigh_put(hardif_neigh);
- 	return neigh_node;
--- 
-2.8.0.rc3
-
diff --git a/batman-adv/patches/0003-batman-adv-Avoid-nullptr-derefence-in-batadv_v_neigh.patch b/batman-adv/patches/0003-batman-adv-Avoid-nullptr-derefence-in-batadv_v_neigh.patch
deleted file mode 100644
index aa07ad5..0000000
--- a/batman-adv/patches/0003-batman-adv-Avoid-nullptr-derefence-in-batadv_v_neigh.patch
+++ /dev/null
@@ -1,38 +0,0 @@
-From 036aa7b7181ee96ae6971eb31dd97b6ace7c0a80 Mon Sep 17 00:00:00 2001
-From: Sven Eckelmann <sven@narfation.org>
-Date: Fri, 6 May 2016 11:43:38 +0200
-Subject: [PATCH 3/6] batman-adv: Avoid nullptr derefence in
- batadv_v_neigh_is_sob
-
-batadv_neigh_ifinfo_get can return NULL when it cannot find (even when only
-temporarily) anymore the neigh_ifinfo in the list neigh->ifinfo_list. This
-has to be checked to avoid kernel Oopses when the ifinfo is dereferenced.
-
-This a situation which isn't expected but is already handled by functions
-like batadv_v_neigh_cmp. The same kind of warning is therefore used before
-the function returns without dereferencing the pointers.
-
-Fixes: b05bbab5e1fc ("batman-adv: B.A.T.M.A.N. V - implement neighbor comparison API calls")
-Signed-off-by: Sven Eckelmann <sven@narfation.org>
-Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
----
- net/batman-adv/bat_v.c | 3 +++
- 1 file changed, 3 insertions(+)
-
-diff --git a/net/batman-adv/bat_v.c b/net/batman-adv/bat_v.c
-index 4547fce..7e1467a 100644
---- a/net/batman-adv/bat_v.c
-+++ b/net/batman-adv/bat_v.c
-@@ -295,6 +295,9 @@ static bool batadv_v_neigh_is_sob(struct batadv_neigh_node *neigh1,
- 	ifinfo1 = batadv_neigh_ifinfo_get(neigh1, if_outgoing1);
- 	ifinfo2 = batadv_neigh_ifinfo_get(neigh2, if_outgoing2);
- 
-+	if (WARN_ON(!ifinfo1 || !ifinfo2))
-+		return false;
-+
- 	threshold = ifinfo1->bat_v.throughput / 4;
- 	threshold = ifinfo1->bat_v.throughput - threshold;
- 
--- 
-2.8.0.rc3
-
diff --git a/batman-adv/patches/0004-batman-adv-Fix-refcnt-leak-in-batadv_v_neigh_.patch b/batman-adv/patches/0004-batman-adv-Fix-refcnt-leak-in-batadv_v_neigh_.patch
deleted file mode 100644
index 15ef21c..0000000
--- a/batman-adv/patches/0004-batman-adv-Fix-refcnt-leak-in-batadv_v_neigh_.patch
+++ /dev/null
@@ -1,81 +0,0 @@
-From 650d41de4be2fe9e9d1842c1abdd357dedbaa7ba Mon Sep 17 00:00:00 2001
-From: Sven Eckelmann <sven@narfation.org>
-Date: Fri, 6 May 2016 11:43:39 +0200
-Subject: [PATCH 4/6] batman-adv: Fix refcnt leak in batadv_v_neigh_*
-
-The functions batadv_neigh_ifinfo_get increase the reference counter of the
-batadv_neigh_ifinfo. These have to be reduced again when the reference is
-not used anymore to correctly free the objects.
-
-Fixes: b05bbab5e1fc ("batman-adv: B.A.T.M.A.N. V - implement neighbor comparison API calls")
-Signed-off-by: Sven Eckelmann <sven@narfation.org>
-Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
----
- net/batman-adv/bat_v.c | 32 +++++++++++++++++++++++++-------
- 1 file changed, 25 insertions(+), 7 deletions(-)
-
-diff --git a/net/batman-adv/bat_v.c b/net/batman-adv/bat_v.c
-index 7e1467a..2bcb29b 100644
---- a/net/batman-adv/bat_v.c
-+++ b/net/batman-adv/bat_v.c
-@@ -274,14 +274,23 @@ static int batadv_v_neigh_cmp(struct batadv_neigh_node *neigh1,
- 			      struct batadv_hard_iface *if_outgoing2)
- {
- 	struct batadv_neigh_ifinfo *ifinfo1, *ifinfo2;
-+	int ret = 0;
- 
- 	ifinfo1 = batadv_neigh_ifinfo_get(neigh1, if_outgoing1);
-+	if (WARN_ON(!ifinfo1))
-+		goto err_ifinfo1;
-+
- 	ifinfo2 = batadv_neigh_ifinfo_get(neigh2, if_outgoing2);
-+	if (WARN_ON(!ifinfo2))
-+		goto err_ifinfo2;
- 
--	if (WARN_ON(!ifinfo1 || !ifinfo2))
--		return 0;
-+	ret = ifinfo1->bat_v.throughput - ifinfo2->bat_v.throughput;
- 
--	return ifinfo1->bat_v.throughput - ifinfo2->bat_v.throughput;
-+	batadv_neigh_ifinfo_put(ifinfo2);
-+err_ifinfo2:
-+	batadv_neigh_ifinfo_put(ifinfo1);
-+err_ifinfo1:
-+	return ret;
- }
- 
- static bool batadv_v_neigh_is_sob(struct batadv_neigh_node *neigh1,
-@@ -291,17 +300,26 @@ static bool batadv_v_neigh_is_sob(struct batadv_neigh_node *neigh1,
- {
- 	struct batadv_neigh_ifinfo *ifinfo1, *ifinfo2;
- 	u32 threshold;
-+	bool ret = false;
- 
- 	ifinfo1 = batadv_neigh_ifinfo_get(neigh1, if_outgoing1);
--	ifinfo2 = batadv_neigh_ifinfo_get(neigh2, if_outgoing2);
-+	if (WARN_ON(!ifinfo1))
-+		goto err_ifinfo1;
- 
--	if (WARN_ON(!ifinfo1 || !ifinfo2))
--		return false;
-+	ifinfo2 = batadv_neigh_ifinfo_get(neigh2, if_outgoing2);
-+	if (WARN_ON(!ifinfo2))
-+		goto err_ifinfo2;
- 
- 	threshold = ifinfo1->bat_v.throughput / 4;
- 	threshold = ifinfo1->bat_v.throughput - threshold;
- 
--	return ifinfo2->bat_v.throughput > threshold;
-+	ret = ifinfo2->bat_v.throughput > threshold;
-+
-+	batadv_neigh_ifinfo_put(ifinfo2);
-+err_ifinfo2:
-+	batadv_neigh_ifinfo_put(ifinfo1);
-+err_ifinfo1:
-+	return ret;
- }
- 
- static struct batadv_algo_ops batadv_batman_v __read_mostly = {
--- 
-2.8.0.rc3
-
diff --git a/batman-adv/patches/0005-batman-adv-Fix-double-neigh_node_put-in-batadv_v_ogm.patch b/batman-adv/patches/0005-batman-adv-Fix-double-neigh_node_put-in-batadv_v_ogm.patch
deleted file mode 100644
index 8ea3788..0000000
--- a/batman-adv/patches/0005-batman-adv-Fix-double-neigh_node_put-in-batadv_v_ogm.patch
+++ /dev/null
@@ -1,40 +0,0 @@
-From fc3e79d9ef2a1006f94e441d9613749cbbe7176a Mon Sep 17 00:00:00 2001
-From: Sven Eckelmann <sven@narfation.org>
-Date: Fri, 6 May 2016 22:27:09 +0200
-Subject: [PATCH 5/6] batman-adv: Fix double neigh_node_put in
- batadv_v_ogm_route_update
-
-The router is put down twice when it was non-NULL and either orig_ifinfo is
-NULL afterwards or batman-adv receives a packet with the same sequence
-number. This will end up in a use-after-free when the batadv_neigh_node is
-removed because the reference counter ended up too early at 0.
-
-Fixes: 667996ebeab4 ("batman-adv: OGMv2 - implement originators logic")
-Reported-by: Gui Iribarren <gui@altermundi.net>
-Tested-by: Antonio Quartulli <a@unstable.cc>
-Tested-by: Marek Lindner <mareklindner@neomailbox.ch>
-Signed-off-by: Sven Eckelmann <sven@narfation.org>
-Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
----
- net/batman-adv/bat_v_ogm.c | 4 +++-
- 1 file changed, 3 insertions(+), 1 deletion(-)
-
-diff --git a/net/batman-adv/bat_v_ogm.c b/net/batman-adv/bat_v_ogm.c
-index d9bcbe6..91df28a 100644
---- a/net/batman-adv/bat_v_ogm.c
-+++ b/net/batman-adv/bat_v_ogm.c
-@@ -529,8 +529,10 @@ static void batadv_v_ogm_route_update(struct batadv_priv *bat_priv,
- 		goto out;
- 	}
- 
--	if (router)
-+	if (router) {
- 		batadv_neigh_node_put(router);
-+		router = NULL;
-+	}
- 
- 	/* Update routes, and check if the OGM is from the best next hop */
- 	batadv_v_ogm_orig_update(bat_priv, orig_node, neigh_node, ogm2,
--- 
-2.8.0.rc3
-
diff --git a/batman-adv/patches/0006-batman-adv-initialize-ELP-orig-address-on-secondary-.patch b/batman-adv/patches/0006-batman-adv-initialize-ELP-orig-address-on-secondary-.patch
deleted file mode 100644
index f87ddf0..0000000
--- a/batman-adv/patches/0006-batman-adv-initialize-ELP-orig-address-on-secondary-.patch
+++ /dev/null
@@ -1,110 +0,0 @@
-From f58a0b03873fd3aa9568c11af198f997ed2208cc Mon Sep 17 00:00:00 2001
-From: Marek Lindner <mareklindner@neomailbox.ch>
-Date: Sat, 7 May 2016 19:54:17 +0800
-Subject: [PATCH 6/6] batman-adv: initialize ELP orig address on secondary
- interfaces
-
-This fix prevents nodes to wrongly create a 00:00:00:00:00:00 originator
-which can potentially interfere with the rest of the neighbor statistics.
-
-Fixes: a4b88af77e28 ("batman-adv: ELP - adding basic infrastructure")
-Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
----
- net/batman-adv/bat_v.c     | 10 ++++++++++
- net/batman-adv/bat_v_elp.c | 31 ++++++++++++++++++++++---------
- net/batman-adv/bat_v_elp.h |  2 ++
- 3 files changed, 34 insertions(+), 9 deletions(-)
-
-diff --git a/net/batman-adv/bat_v.c b/net/batman-adv/bat_v.c
-index 2bcb29b..0caca2f 100644
---- a/net/batman-adv/bat_v.c
-+++ b/net/batman-adv/bat_v.c
-@@ -39,6 +39,16 @@
- 
- static void batadv_v_iface_activate(struct batadv_hard_iface *hard_iface)
- {
-+	struct batadv_priv *bat_priv = netdev_priv(hard_iface->soft_iface);
-+	struct batadv_hard_iface *primary_if;
-+
-+	primary_if = batadv_primary_if_get_selected(bat_priv);
-+
-+	if (primary_if) {
-+		batadv_v_elp_iface_activate(primary_if, hard_iface);
-+		batadv_hardif_put(primary_if);
-+	}
-+
- 	/* B.A.T.M.A.N. V does not use any queuing mechanism, therefore it can
- 	 * set the interface as ACTIVE right away, without any risk of race
- 	 * condition
-diff --git a/net/batman-adv/bat_v_elp.c b/net/batman-adv/bat_v_elp.c
-index 3844e7e..df42eb1 100644
---- a/net/batman-adv/bat_v_elp.c
-+++ b/net/batman-adv/bat_v_elp.c
-@@ -377,6 +377,27 @@ void batadv_v_elp_iface_disable(struct batadv_hard_iface *hard_iface)
- }
- 
- /**
-+ * batadv_v_elp_iface_activate - update the ELP buffer belonging to the given
-+ *  hard-interface
-+ * @primary_iface: the new primary interface
-+ * @hard_iface: interface holding the to-be-updated buffer
-+ */
-+void batadv_v_elp_iface_activate(struct batadv_hard_iface *primary_iface,
-+				 struct batadv_hard_iface *hard_iface)
-+{
-+	struct batadv_elp_packet *elp_packet;
-+	struct sk_buff *skb;
-+
-+	if (!hard_iface->bat_v.elp_skb)
-+		return;
-+
-+	skb = hard_iface->bat_v.elp_skb;
-+	elp_packet = (struct batadv_elp_packet *)skb->data;
-+	ether_addr_copy(elp_packet->orig,
-+			primary_iface->net_dev->dev_addr);
-+}
-+
-+/**
-  * batadv_v_elp_primary_iface_set - change internal data to reflect the new
-  *  primary interface
-  * @primary_iface: the new primary interface
-@@ -384,8 +405,6 @@ void batadv_v_elp_iface_disable(struct batadv_hard_iface *hard_iface)
- void batadv_v_elp_primary_iface_set(struct batadv_hard_iface *primary_iface)
- {
- 	struct batadv_hard_iface *hard_iface;
--	struct batadv_elp_packet *elp_packet;
--	struct sk_buff *skb;
- 
- 	/* update orig field of every elp iface belonging to this mesh */
- 	rcu_read_lock();
-@@ -393,13 +412,7 @@ void batadv_v_elp_primary_iface_set(struct batadv_hard_iface *primary_iface)
- 		if (primary_iface->soft_iface != hard_iface->soft_iface)
- 			continue;
- 
--		if (!hard_iface->bat_v.elp_skb)
--			continue;
--
--		skb = hard_iface->bat_v.elp_skb;
--		elp_packet = (struct batadv_elp_packet *)skb->data;
--		ether_addr_copy(elp_packet->orig,
--				primary_iface->net_dev->dev_addr);
-+		batadv_v_elp_iface_activate(primary_iface, hard_iface);
- 	}
- 	rcu_read_unlock();
- }
-diff --git a/net/batman-adv/bat_v_elp.h b/net/batman-adv/bat_v_elp.h
-index e95f1bc..cc130b2 100644
---- a/net/batman-adv/bat_v_elp.h
-+++ b/net/batman-adv/bat_v_elp.h
-@@ -25,6 +25,8 @@ struct work_struct;
- 
- int batadv_v_elp_iface_enable(struct batadv_hard_iface *hard_iface);
- void batadv_v_elp_iface_disable(struct batadv_hard_iface *hard_iface);
-+void batadv_v_elp_iface_activate(struct batadv_hard_iface *primary_iface,
-+				 struct batadv_hard_iface *hard_iface);
- void batadv_v_elp_primary_iface_set(struct batadv_hard_iface *primary_iface);
- int batadv_v_elp_packet_recv(struct sk_buff *skb,
- 			     struct batadv_hard_iface *if_incoming);
--- 
-2.8.0.rc3
-
diff --git a/batman-adv/patches/0007-batman-adv-Add-missing-include-for-batadv_v_neigh_is.patch b/batman-adv/patches/0007-batman-adv-Add-missing-include-for-batadv_v_neigh_is.patch
deleted file mode 100644
index 82ffd07..0000000
--- a/batman-adv/patches/0007-batman-adv-Add-missing-include-for-batadv_v_neigh_is.patch
+++ /dev/null
@@ -1,28 +0,0 @@
-From: Sven Eckelmann <sven@narfation.org>
-Date: Sat, 7 May 2016 09:50:44 +0200
-Subject: [PATCH] batman-adv: Add missing include for batadv_v_neigh_is_sob
-
-batadv_v_neigh_is_sob started to use false which is defined in
-linux/stddef.h.
-
-Fixes: 036aa7b7181e ("batman-adv: Avoid nullptr derefence in batadv_v_neigh_is_sob")
-Signed-off-by: Sven Eckelmann <sven@narfation.org>
-Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
-
-Origin: upstream, https://git.open-mesh.org/batman-adv.git/commit/9685688ae7dd85804aec2f6ce760611551fe9635
----
- net/batman-adv/bat_v.c | 1 +
- 1 file changed, 1 insertion(+)
-
-diff --git a/net/batman-adv/bat_v.c b/net/batman-adv/bat_v.c
-index 0caca2f..1f960c9 100644
---- a/net/batman-adv/bat_v.c
-+++ b/net/batman-adv/bat_v.c
-@@ -27,6 +27,7 @@
- #include <linux/rculist.h>
- #include <linux/rcupdate.h>
- #include <linux/seq_file.h>
-+#include <linux/stddef.h>
- #include <linux/types.h>
- #include <linux/workqueue.h>
- 
diff --git a/batman-adv/patches/0008-batman-adv-fix-skb-deref-after-free.patch b/batman-adv/patches/0008-batman-adv-fix-skb-deref-after-free.patch
deleted file mode 100644
index 5c8bfd8..0000000
--- a/batman-adv/patches/0008-batman-adv-fix-skb-deref-after-free.patch
+++ /dev/null
@@ -1,46 +0,0 @@
-From: Florian Westphal <fw@strlen.de>
-Date: Tue, 10 May 2016 23:17:59 +0200
-Subject: [PATCH] batman-adv: fix skb deref after free
-
-batadv_send_skb_to_orig() calls dev_queue_xmit() so we can't use skb->len.
-
-Fixes: d28785996ad8 ("batman-adv: network coding - buffer unicast packets before forward")
-
-Signed-off-by: Florian Westphal <fw@strlen.de>
-Reviewed-by: Sven Eckelmann <sven@narfation.org>
-Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
-
-Origin: upstream, https://git.open-mesh.org/batman-adv.git/commit/6863d3b59fd1f1bef3c4b86707a0b1c5d21e0a07
----
- net/batman-adv/routing.c | 4 +++-
- 1 file changed, 3 insertions(+), 1 deletion(-)
-
-diff --git a/net/batman-adv/routing.c b/net/batman-adv/routing.c
-index b781bf7..0c0c30e 100644
---- a/net/batman-adv/routing.c
-+++ b/net/batman-adv/routing.c
-@@ -601,6 +601,7 @@ static int batadv_route_unicast_packet(struct sk_buff *skb,
- 	struct batadv_unicast_packet *unicast_packet;
- 	struct ethhdr *ethhdr = eth_hdr(skb);
- 	int res, hdr_len, ret = NET_RX_DROP;
-+	unsigned int len;
- 
- 	unicast_packet = (struct batadv_unicast_packet *)skb->data;
- 
-@@ -641,6 +642,7 @@ static int batadv_route_unicast_packet(struct sk_buff *skb,
- 	if (hdr_len > 0)
- 		batadv_skb_set_priority(skb, hdr_len);
- 
-+	len = skb->len;
- 	res = batadv_send_skb_to_orig(skb, orig_node, recv_if);
- 
- 	/* translate transmit result into receive result */
-@@ -648,7 +650,7 @@ static int batadv_route_unicast_packet(struct sk_buff *skb,
- 		/* skb was transmitted and consumed */
- 		batadv_inc_counter(bat_priv, BATADV_CNT_FORWARD);
- 		batadv_add_counter(bat_priv, BATADV_CNT_FORWARD_BYTES,
--				   skb->len + ETH_HLEN);
-+				   len + ETH_HLEN);
- 
- 		ret = NET_RX_SUCCESS;
- 	} else if (res == NET_XMIT_POLICED) {
diff --git a/batman-adv/patches/0009-batman-adv-replace-WARN-with-rate-limited-output-on-.patch b/batman-adv/patches/0009-batman-adv-replace-WARN-with-rate-limited-output-on-.patch
deleted file mode 100644
index 07274b6..0000000
--- a/batman-adv/patches/0009-batman-adv-replace-WARN-with-rate-limited-output-on-.patch
+++ /dev/null
@@ -1,40 +0,0 @@
-From: Simon Wunderlich <sw@simonwunderlich.de>
-Date: Thu, 12 May 2016 18:52:03 +0200
-Subject: [PATCH] batman-adv: replace WARN with rate limited output on non-existing VLAN
-
-If a VLAN tagged frame is received and the corresponding VLAN is not
-configured on the soft interface, it will splat a WARN on every packet
-received. This is a quite annoying behaviour for some scenarios, e.g. if
-bat0 is bridged with eth0, and there are arbitrary VLAN tagged frames
-from Ethernet coming in without having any VLAN configuration on bat0.
-
-The code should probably create vlan objects on the fly and
-transparently transport these VLAN-tagged Ethernet frames, but until
-this is done, at least the WARN splat should be replaced by a rate
-limited output.
-
-Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
-Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
-
-Origin: upstream, https://git.open-mesh.org/batman-adv.git/commit/04792115d24408a72bf8fccd5c4059478fc15eae
----
- net/batman-adv/translation-table.c | 6 ++++--
- 1 file changed, 4 insertions(+), 2 deletions(-)
-
-diff --git a/net/batman-adv/translation-table.c b/net/batman-adv/translation-table.c
-index 9b4551a..48adb91 100644
---- a/net/batman-adv/translation-table.c
-+++ b/net/batman-adv/translation-table.c
-@@ -650,8 +650,10 @@ bool batadv_tt_local_add(struct net_device *soft_iface, const u8 *addr,
- 
- 	/* increase the refcounter of the related vlan */
- 	vlan = batadv_softif_vlan_get(bat_priv, vid);
--	if (WARN(!vlan, "adding TT local entry %pM to non-existent VLAN %d",
--		 addr, BATADV_PRINT_VID(vid))) {
-+	if (!vlan) {
-+		net_ratelimited_function(batadv_info, soft_iface,
-+					 "adding TT local entry %pM to non-existent VLAN %d\n",
-+					 addr, BATADV_PRINT_VID(vid));
- 		kfree(tt_local);
- 		tt_local = NULL;
- 		goto out;
diff --git a/batman-adv/patches/0010-batman-adv-Fix-build-against-recent-Debian-Stretch-k.patch b/batman-adv/patches/0010-batman-adv-Fix-build-against-recent-Debian-Stretch-k.patch
deleted file mode 100644
index 127cac8..0000000
--- a/batman-adv/patches/0010-batman-adv-Fix-build-against-recent-Debian-Stretch-k.patch
+++ /dev/null
@@ -1,58 +0,0 @@
-From: Sven Eckelmann <sven@narfation.org>
-Date: Sat, 28 May 2016 10:32:48 +0200
-Subject: [PATCH] batman-adv: Fix build against recent Debian Stretch kernels
-
-The kernels for Debian stretch require some special CFLAGS settings which
-are only correctly defined when NOSTDINC_FLAGS is defined inside the
-execution of the Makefile via kbuild. But batman-adv sets it currently
-outside to insert compatibility include headers and compat-sources.
-
-This can be avoided by making the top Makefile kbuild compatible and
-redefining the NOSTDINC_FLAGS when kbuild include this Makefile. The actual
-build of the batman-adv module is then done by adding the subdirectory to
-obj-y.
-
-Signed-off-by: Sven Eckelmann <sven@narfation.org>
-Tested-by: Martin Weinelt <martin@darmstadt.freifunk.net>
-
-Origin: https://git.open-mesh.org/batman-adv.git/commit/f8fd441e1e30f3a274c9bf44cc33372d4065cbb6
----
- Makefile | 10 +++++++---
- 1 file changed, 7 insertions(+), 3 deletions(-)
-
-diff --git a/Makefile b/Makefile
-index 5d2c058..2568fb2 100644
---- a/Makefile
-+++ b/Makefile
-@@ -43,7 +43,7 @@ RM ?= rm -f
- REVISION= $(shell	if [ -d "$(PWD)/.git" ]; then \
- 				echo $$(git --git-dir="$(PWD)/.git" describe --always --dirty --match "v*" |sed 's/^v//' 2> /dev/null || echo "[unknown]"); \
- 			fi)
--export NOSTDINC_FLAGS := \
-+NOSTDINC_FLAGS += \
- 	-I$(PWD)/compat-include/ \
- 	-include $(PWD)/compat.h \
- 	$(CFLAGS)
-@@ -52,8 +52,12 @@ ifneq ($(REVISION),)
- NOSTDINC_FLAGS += -DBATADV_SOURCE_VERSION=\"$(REVISION)\"
- endif
- 
-+obj-y += net/batman-adv/
-+
- BUILD_FLAGS := \
--	M=$(PWD)/net/batman-adv \
-+	M=$(PWD) \
-+	PWD=$(PWD) \
-+	REVISION=$(REVISION) \
- 	CONFIG_BATMAN_ADV=m \
- 	CONFIG_BATMAN_ADV_DEBUG=$(CONFIG_BATMAN_ADV_DEBUG) \
- 	CONFIG_BATMAN_ADV_BLA=$(CONFIG_BATMAN_ADV_BLA) \
-@@ -61,7 +65,7 @@ BUILD_FLAGS := \
- 	CONFIG_BATMAN_ADV_NC=$(CONFIG_BATMAN_ADV_NC) \
- 	CONFIG_BATMAN_ADV_MCAST=$(CONFIG_BATMAN_ADV_MCAST) \
- 	CONFIG_BATMAN_ADV_BATMAN_V=$(CONFIG_BATMAN_ADV_BATMAN_V) \
--	INSTALL_MOD_DIR=updates/net/batman-adv/
-+	INSTALL_MOD_DIR=updates/
- 
- all: config
- 	$(MAKE) -C $(KERNELPATH) $(BUILD_FLAGS)	modules
diff --git a/batman-adv/patches/0011-batman-adv-Clean-up-untagged-vlan-when-destroying-vi.patch b/batman-adv/patches/0011-batman-adv-Clean-up-untagged-vlan-when-destroying-vi.patch
deleted file mode 100644
index b03d795..0000000
--- a/batman-adv/patches/0011-batman-adv-Clean-up-untagged-vlan-when-destroying-vi.patch
+++ /dev/null
@@ -1,45 +0,0 @@
-From: Sven Eckelmann <sven@narfation.org>
-Date: Sat, 28 May 2016 14:38:26 +0200
-Subject: [PATCH] batman-adv: Clean up untagged vlan when destroying via rtnl-link
-
-The untagged vlan object is only destroyed when the interface is removed
-via the legacy sysfs interface. But it also has to be destroyed when the
-standard rtnl-link interface is used.
-
-Fixes: 952cebb57518 ("batman-adv: add per VLAN interface attribute framework")
-Signed-off-by: Sven Eckelmann <sven@narfation.org>
-Cc: Antonio Quartulli <a@unstable.cc>
-
-Origin: https://git.open-mesh.org/batman-adv.git/commit/e721749d57ff57d6df4017d62797626eab9902f1
----
- net/batman-adv/soft-interface.c | 9 +++++++++
- 1 file changed, 9 insertions(+)
-
-diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
-index 8a136b6..3710620 100644
---- a/net/batman-adv/soft-interface.c
-+++ b/net/batman-adv/soft-interface.c
-@@ -1017,7 +1017,9 @@ void batadv_softif_destroy_sysfs(struct net_device *soft_iface)
- static void batadv_softif_destroy_netlink(struct net_device *soft_iface,
- 					  struct list_head *head)
- {
-+	struct batadv_priv *bat_priv = netdev_priv(soft_iface);
- 	struct batadv_hard_iface *hard_iface;
-+	struct batadv_softif_vlan *vlan;
- 
- 	list_for_each_entry(hard_iface, &batadv_hardif_list, list) {
- 		if (hard_iface->soft_iface == soft_iface)
-@@ -1025,6 +1027,13 @@ static void batadv_softif_destroy_netlink(struct net_device *soft_iface,
- 							BATADV_IF_CLEANUP_KEEP);
- 	}
- 
-+	/* destroy the "untagged" VLAN */
-+	vlan = batadv_softif_vlan_get(bat_priv, BATADV_NO_FLAGS);
-+	if (vlan) {
-+		batadv_softif_destroy_vlan(bat_priv, vlan);
-+		batadv_softif_vlan_put(vlan);
-+	}
-+
- 	batadv_sysfs_del_meshif(soft_iface);
- 	unregister_netdevice_queue(soft_iface, head);
- }
diff --git a/batman-adv/patches/0012-batman-adv-Fix-ICMP-RR-ethernet-access-after-skb_lin.patch b/batman-adv/patches/0012-batman-adv-Fix-ICMP-RR-ethernet-access-after-skb_lin.patch
deleted file mode 100644
index 5204cdc..0000000
--- a/batman-adv/patches/0012-batman-adv-Fix-ICMP-RR-ethernet-access-after-skb_lin.patch
+++ /dev/null
@@ -1,31 +0,0 @@
-From: Sven Eckelmann <sven@narfation.org>
-Date: Sun, 29 May 2016 21:25:52 +0200
-Subject: [PATCH] batman-adv: Fix ICMP RR ethernet access after skb_linearize
-
-The skb_linearize may reallocate the skb. This makes the calculated pointer
-for ethhdr invalid. But it the pointer is used later to fill in the RR
-field of the batadv_icmp_packet_rr packet.
-
-Instead re-evaluate eth_hdr after the skb_linearize+skb_cow to fix the
-pointer and avoid the invalid read.
-
-Fixes: bb69cb678d37 ("batman-adv: generalize batman-adv icmp packet handling")
-Signed-off-by: Sven Eckelmann <sven@narfation.org>
-
-Origin: upstream, https://git.open-mesh.org/batman-adv.git/commit/f6c80c29ef4e8b45b715976107b7ae06fc0be3a0
----
- net/batman-adv/routing.c | 1 +
- 1 file changed, 1 insertion(+)
-
-diff --git a/net/batman-adv/routing.c b/net/batman-adv/routing.c
-index 0c0c30e..27e07dd 100644
---- a/net/batman-adv/routing.c
-+++ b/net/batman-adv/routing.c
-@@ -374,6 +374,7 @@ int batadv_recv_icmp_packet(struct sk_buff *skb,
- 		if (skb_cow(skb, ETH_HLEN) < 0)
- 			goto out;
- 
-+		ethhdr = eth_hdr(skb);
- 		icmph = (struct batadv_icmp_header *)skb->data;
- 		icmp_packet_rr = (struct batadv_icmp_packet_rr *)icmph;
- 		if (icmp_packet_rr->rr_cur >= BATADV_RR_LEN)
diff --git a/batman-adv/patches/0013-batman-adv-Fix-double-put-of-vlan-object.patch b/batman-adv/patches/0013-batman-adv-Fix-double-put-of-vlan-object.patch
deleted file mode 100644
index 6ea8311..0000000
--- a/batman-adv/patches/0013-batman-adv-Fix-double-put-of-vlan-object.patch
+++ /dev/null
@@ -1,32 +0,0 @@
-From: Ben Hutchings <ben@decadent.org.uk>
-Date: Fri, 3 Jun 2016 00:00:44 +0100
-Subject: [PATCH] batman-adv: Fix double-put of vlan object
-
-Commit a33d970d0b54 "batman-adv: Fix reference counting of vlan object
-for tt_local_entry") makes each batadv_tt_local_entry hold a single
-reference to a batadv_softif_vlan.  In case a new entry cannot be
-added to the hash table, the error path puts the reference, but the
-reference will also now be dropped by batadv_tt_local_entry_release().
-
-Fixes: a33d970d0b54 ("batman-adv: Fix reference counting of vlan object ...")
-Cc: Sven Eckelmann <sven@narfation.org>
-Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
-Acked-by: Sven Eckelmann <sven@narfation.org>
-
-Origin: upstream, https://git.open-mesh.org/batman-adv.git/commit/22bb8b894900064d3fb09032a47577e89fc30d7c
----
- net/batman-adv/translation-table.c | 1 -
- 1 file changed, 1 deletion(-)
-
-diff --git a/net/batman-adv/translation-table.c b/net/batman-adv/translation-table.c
-index 48adb91..5ed782b 100644
---- a/net/batman-adv/translation-table.c
-+++ b/net/batman-adv/translation-table.c
-@@ -693,7 +693,6 @@ bool batadv_tt_local_add(struct net_device *soft_iface, const u8 *addr,
- 	if (unlikely(hash_added != 0)) {
- 		/* remove the reference for the hash */
- 		batadv_tt_local_entry_put(tt_local);
--		batadv_softif_vlan_put(vlan);
- 		goto out;
- 	}
- 
diff --git a/batman-adv/patches/0014-batman-adv-Fix-use-after-free-double-free-of-tt_req_.patch b/batman-adv/patches/0014-batman-adv-Fix-use-after-free-double-free-of-tt_req_.patch
deleted file mode 100644
index 33c7f3b..0000000
--- a/batman-adv/patches/0014-batman-adv-Fix-use-after-free-double-free-of-tt_req_.patch
+++ /dev/null
@@ -1,172 +0,0 @@
-From: Sven Eckelmann <sven@narfation.org>
-Date: Sat, 4 Jun 2016 08:52:12 +0200
-Subject: [PATCH] batman-adv: Fix use-after-free/double-free of tt_req_node
-
-The tt_req_node is added and removed from a list inside a spinlock. But the
-locking is sometimes removed even when the object is still referenced and
-will be used later via this reference. For example batadv_send_tt_request
-can create a new tt_req_node (including add to a list) and later
-re-acquires the lock to remove it from the list and to free it. But at this
-time another context could have already removed this tt_req_node from the
-list and freed it.
-
-CPU#0
-
-    batadv_batman_skb_recv from net_device 0
-    -> batadv_iv_ogm_receive
-      -> batadv_iv_ogm_process
-        -> batadv_iv_ogm_process_per_outif
-          -> batadv_tvlv_ogm_receive
-            -> batadv_tvlv_ogm_receive
-              -> batadv_tvlv_containers_process
-                -> batadv_tvlv_call_handler
-                  -> batadv_tt_tvlv_ogm_handler_v1
-                    -> batadv_tt_update_orig
-                      -> batadv_send_tt_request
-                        -> batadv_tt_req_node_new
-                           spin_lock(...)
-                           allocates new tt_req_node and adds it to list
-                           spin_unlock(...)
-                           return tt_req_node
-
-CPU#1
-
-    batadv_batman_skb_recv from net_device 1
-    -> batadv_recv_unicast_tvlv
-      -> batadv_tvlv_containers_process
-        -> batadv_tvlv_call_handler
-          -> batadv_tt_tvlv_unicast_handler_v1
-            -> batadv_handle_tt_response
-               spin_lock(...)
-               tt_req_node gets removed from list and is freed
-               spin_unlock(...)
-
-CPU#0
-
-                      <- returned to batadv_send_tt_request
-                         spin_lock(...)
-                         tt_req_node gets removed from list and is freed
-                         MEMORY CORRUPTION/SEGFAULT/...
-                         spin_unlock(...)
-
-This can only be solved via reference counting to allow multiple contexts
-to handle the list manipulation while making sure that only the last
-context holding a reference will free the object.
-
-Fixes: cea194d90b11 ("batman-adv: improved client announcement mechanism")
-Signed-off-by: Sven Eckelmann <sven@narfation.org>
-Tested-by: Martin Weinelt <martin@darmstadt.freifunk.net>
-Tested-by: Amadeus Alfa <amadeus@chemnitz.freifunk.net>
-
-Origin: upstream, https://git.open-mesh.org/batman-adv.git/commit/c3fef3d9ec6e8b882f321ec20f6f2cb2ee906503
----
- net/batman-adv/translation-table.c | 37 +++++++++++++++++++++++++++++++++----
- net/batman-adv/types.h             |  2 ++
- 2 files changed, 35 insertions(+), 4 deletions(-)
-
-diff --git a/net/batman-adv/translation-table.c b/net/batman-adv/translation-table.c
-index 5ed782b..23fb7ea 100644
---- a/net/batman-adv/translation-table.c
-+++ b/net/batman-adv/translation-table.c
-@@ -2271,6 +2271,29 @@ static u32 batadv_tt_local_crc(struct batadv_priv *bat_priv,
- 	return crc;
- }
- 
-+/**
-+ * batadv_tt_req_node_release - free tt_req node entry
-+ * @ref: kref pointer of the tt req_node entry
-+ */
-+static void batadv_tt_req_node_release(struct kref *ref)
-+{
-+	struct batadv_tt_req_node *tt_req_node;
-+
-+	tt_req_node = container_of(ref, struct batadv_tt_req_node, refcount);
-+
-+	kfree(tt_req_node);
-+}
-+
-+/**
-+ * batadv_tt_req_node_put - decrement the tt_req_node refcounter and
-+ *  possibly release it
-+ * @tt_req_node: tt_req_node to be free'd
-+ */
-+static void batadv_tt_req_node_put(struct batadv_tt_req_node *tt_req_node)
-+{
-+	kref_put(&tt_req_node->refcount, batadv_tt_req_node_release);
-+}
-+
- static void batadv_tt_req_list_free(struct batadv_priv *bat_priv)
- {
- 	struct batadv_tt_req_node *node;
-@@ -2280,7 +2303,7 @@ static void batadv_tt_req_list_free(struct batadv_priv *bat_priv)
- 
- 	hlist_for_each_entry_safe(node, safe, &bat_priv->tt.req_list, list) {
- 		hlist_del_init(&node->list);
--		kfree(node);
-+		batadv_tt_req_node_put(node);
- 	}
- 
- 	spin_unlock_bh(&bat_priv->tt.req_list_lock);
-@@ -2317,7 +2340,7 @@ static void batadv_tt_req_purge(struct batadv_priv *bat_priv)
- 		if (batadv_has_timed_out(node->issued_at,
- 					 BATADV_TT_REQUEST_TIMEOUT)) {
- 			hlist_del_init(&node->list);
--			kfree(node);
-+			batadv_tt_req_node_put(node);
- 		}
- 	}
- 	spin_unlock_bh(&bat_priv->tt.req_list_lock);
-@@ -2349,9 +2372,11 @@ batadv_tt_req_node_new(struct batadv_priv *bat_priv,
- 	if (!tt_req_node)
- 		goto unlock;
- 
-+	kref_init(&tt_req_node->refcount);
- 	ether_addr_copy(tt_req_node->addr, orig_node->orig);
- 	tt_req_node->issued_at = jiffies;
- 
-+	kref_get(&tt_req_node->refcount);
- 	hlist_add_head(&tt_req_node->list, &bat_priv->tt.req_list);
- unlock:
- 	spin_unlock_bh(&bat_priv->tt.req_list_lock);
-@@ -2618,9 +2643,13 @@ out:
- 		spin_lock_bh(&bat_priv->tt.req_list_lock);
- 		/* hlist_del_init() verifies tt_req_node still is in the list */
- 		hlist_del_init(&tt_req_node->list);
-+		batadv_tt_req_node_put(tt_req_node);
- 		spin_unlock_bh(&bat_priv->tt.req_list_lock);
--		kfree(tt_req_node);
- 	}
-+
-+	if (tt_req_node)
-+		batadv_tt_req_node_put(tt_req_node);
-+
- 	kfree(tvlv_tt_data);
- 	return ret;
- }
-@@ -3056,7 +3085,7 @@ static void batadv_handle_tt_response(struct batadv_priv *bat_priv,
- 		if (!batadv_compare_eth(node->addr, resp_src))
- 			continue;
- 		hlist_del_init(&node->list);
--		kfree(node);
-+		batadv_tt_req_node_put(node);
- 	}
- 
- 	spin_unlock_bh(&bat_priv->tt.req_list_lock);
-diff --git a/net/batman-adv/types.h b/net/batman-adv/types.h
-index 1e47fbe..d75beef 100644
---- a/net/batman-adv/types.h
-+++ b/net/batman-adv/types.h
-@@ -1129,11 +1129,13 @@ struct batadv_tt_change_node {
-  * struct batadv_tt_req_node - data to keep track of the tt requests in flight
-  * @addr: mac address address of the originator this request was sent to
-  * @issued_at: timestamp used for purging stale tt requests
-+ * @refcount: number of contexts the object is used by
-  * @list: list node for batadv_priv_tt::req_list
-  */
- struct batadv_tt_req_node {
- 	u8 addr[ETH_ALEN];
- 	unsigned long issued_at;
-+	struct kref refcount;
- 	struct hlist_node list;
- };
- 
diff --git a/batman-adv/patches/0015-batman-adv-Avoid-nullptr-dereference-in-bla-after-vl.patch b/batman-adv/patches/0015-batman-adv-Avoid-nullptr-dereference-in-bla-after-vl.patch
deleted file mode 100644
index 907c1a1..0000000
--- a/batman-adv/patches/0015-batman-adv-Avoid-nullptr-dereference-in-bla-after-vl.patch
+++ /dev/null
@@ -1,35 +0,0 @@
-From: Sven Eckelmann <sven@narfation.org>
-Date: Sat, 2 Jul 2016 09:52:13 +0200
-Subject: [PATCH] batman-adv: Avoid nullptr dereference in bla after vlan_insert_tag
-
-vlan_insert_tag can return NULL on errors. The bridge loop avoidance code
-therefore has to check the return value of vlan_insert_tag for NULL before
-it can safely operate on this pointer.
-
-Fixes: a9ce0dc43e2c ("batman-adv: add basic bridge loop avoidance code")
-Signed-off-by: Sven Eckelmann <sven@narfation.org>
-Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
-
-Origin: upstream, https://git.open-mesh.org/batman-adv.git/commit/e4cffba4d3353ea15287abbfbdd65208aa62c156
----
- net/batman-adv/bridge_loop_avoidance.c | 5 ++++-
- 1 file changed, 4 insertions(+), 1 deletion(-)
-
-diff --git a/net/batman-adv/bridge_loop_avoidance.c b/net/batman-adv/bridge_loop_avoidance.c
-index 0a6c8b8..fe8b62f 100644
---- a/net/batman-adv/bridge_loop_avoidance.c
-+++ b/net/batman-adv/bridge_loop_avoidance.c
-@@ -409,9 +409,12 @@ static void batadv_bla_send_claim(struct batadv_priv *bat_priv, u8 *mac,
- 		break;
- 	}
- 
--	if (vid & BATADV_VLAN_HAS_TAG)
-+	if (vid & BATADV_VLAN_HAS_TAG) {
- 		skb = vlan_insert_tag(skb, htons(ETH_P_8021Q),
- 				      vid & VLAN_VID_MASK);
-+		if (!skb)
-+			goto out;
-+	}
- 
- 	skb_reset_mac_header(skb);
- 	skb->protocol = eth_type_trans(skb, soft_iface);
diff --git a/batman-adv/patches/0016-batman-adv-Avoid-nullptr-dereference-in-dat-after-vl.patch b/batman-adv/patches/0016-batman-adv-Avoid-nullptr-dereference-in-dat-after-vl.patch
deleted file mode 100644
index d896811..0000000
--- a/batman-adv/patches/0016-batman-adv-Avoid-nullptr-dereference-in-dat-after-vl.patch
+++ /dev/null
@@ -1,49 +0,0 @@
-From: Sven Eckelmann <sven@narfation.org>
-Date: Sat, 2 Jul 2016 09:52:14 +0200
-Subject: [PATCH] batman-adv: Avoid nullptr dereference in dat after vlan_insert_tag
-
-vlan_insert_tag can return NULL on errors. The distributed arp table code
-therefore has to check the return value of vlan_insert_tag for NULL before
-it can safely operate on this pointer.
-
-Fixes: 53c6c262a581 ("batman-adv: tag locally generated ARP reply if needed")
-Signed-off-by: Sven Eckelmann <sven@narfation.org>
-Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
-
-Origin: upstream, https://git.open-mesh.org/batman-adv.git/commit/898382d11fa1f737cd4f7033db1088c601fd11ed
----
- net/batman-adv/distributed-arp-table.c | 10 ++++++++--
- 1 file changed, 8 insertions(+), 2 deletions(-)
-
-diff --git a/net/batman-adv/distributed-arp-table.c b/net/batman-adv/distributed-arp-table.c
-index 3e6b262..5a89be0 100644
---- a/net/batman-adv/distributed-arp-table.c
-+++ b/net/batman-adv/distributed-arp-table.c
-@@ -1009,9 +1009,12 @@ bool batadv_dat_snoop_outgoing_arp_request(struct batadv_priv *bat_priv,
- 		if (!skb_new)
- 			goto out;
- 
--		if (vid & BATADV_VLAN_HAS_TAG)
-+		if (vid & BATADV_VLAN_HAS_TAG) {
- 			skb_new = vlan_insert_tag(skb_new, htons(ETH_P_8021Q),
- 						  vid & VLAN_VID_MASK);
-+			if (!skb_new)
-+				goto out;
-+		}
- 
- 		skb_reset_mac_header(skb_new);
- 		skb_new->protocol = eth_type_trans(skb_new,
-@@ -1089,9 +1092,12 @@ bool batadv_dat_snoop_incoming_arp_request(struct batadv_priv *bat_priv,
- 	 */
- 	skb_reset_mac_header(skb_new);
- 
--	if (vid & BATADV_VLAN_HAS_TAG)
-+	if (vid & BATADV_VLAN_HAS_TAG) {
- 		skb_new = vlan_insert_tag(skb_new, htons(ETH_P_8021Q),
- 					  vid & VLAN_VID_MASK);
-+		if (!skb_new)
-+			goto out;
-+	}
- 
- 	/* To preserve backwards compatibility, the node has choose the outgoing
- 	 * format based on the incoming request packet type. The assumption is
diff --git a/batman-adv/patches/0017-batman-adv-Avoid-tt_req_node-list-put-for-unhashed-e.patch b/batman-adv/patches/0017-batman-adv-Avoid-tt_req_node-list-put-for-unhashed-e.patch
deleted file mode 100644
index 09f90d3..0000000
--- a/batman-adv/patches/0017-batman-adv-Avoid-tt_req_node-list-put-for-unhashed-e.patch
+++ /dev/null
@@ -1,41 +0,0 @@
-From: Sven Eckelmann <sven@narfation.org>
-Date: Fri, 24 Jun 2016 21:43:32 +0200
-Subject: [PATCH] batman-adv: Avoid tt_req_node list put for unhashed entry
-
-It can happen that a tt_req_node list entry was already removed from
-tt.req_list when batadv_send_tt_request reaches the end of the function.
-The reference counter was already reduced by 1 for the list entry and thus
-the reference counter is not allowed to be reduced again. Otherwise, the
-entry is freed too early and the next batadv_tt_req_node_put in this
-function will operate on freed memory.
-
-Fixes: cea194d90b11 ("batman-adv: improved client announcement mechanism")
-Signed-off-by: Sven Eckelmann <sven@narfation.org>
-Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
-
-Origin: upstream, https://git.open-mesh.org/batman-adv.git/commit/03ecc9f957b837c755f09251c5f684996521e487
----
- net/batman-adv/translation-table.c | 8 +++++---
- 1 file changed, 5 insertions(+), 3 deletions(-)
-
-diff --git a/net/batman-adv/translation-table.c b/net/batman-adv/translation-table.c
-index 23fb7ea..f7d44c6 100644
---- a/net/batman-adv/translation-table.c
-+++ b/net/batman-adv/translation-table.c
-@@ -2639,11 +2639,13 @@ static int batadv_send_tt_request(struct batadv_priv *bat_priv,
- out:
- 	if (primary_if)
- 		batadv_hardif_put(primary_if);
-+
- 	if (ret && tt_req_node) {
- 		spin_lock_bh(&bat_priv->tt.req_list_lock);
--		/* hlist_del_init() verifies tt_req_node still is in the list */
--		hlist_del_init(&tt_req_node->list);
--		batadv_tt_req_node_put(tt_req_node);
-+		if (!hlist_unhashed(&tt_req_node->list)) {
-+			hlist_del_init(&tt_req_node->list);
-+			batadv_tt_req_node_put(tt_req_node);
-+		}
- 		spin_unlock_bh(&bat_priv->tt.req_list_lock);
- 	}
- 
diff --git a/batman-adv/patches/0018-batman-adv-Fix-orig_node_vlan-leak-on-orig_node_rele.patch b/batman-adv/patches/0018-batman-adv-Fix-orig_node_vlan-leak-on-orig_node_rele.patch
deleted file mode 100644
index 13c74e4..0000000
--- a/batman-adv/patches/0018-batman-adv-Fix-orig_node_vlan-leak-on-orig_node_rele.patch
+++ /dev/null
@@ -1,43 +0,0 @@
-From: Sven Eckelmann <sven@narfation.org>
-Date: Thu, 30 Jun 2016 20:10:46 +0200
-Subject: [PATCH] batman-adv: Fix orig_node_vlan leak on orig_node_release
-
-batadv_orig_node_new uses batadv_orig_node_vlan_new to allocate a new
-batadv_orig_node_vlan and add it to batadv_orig_node::vlan_list. References
-to this list have also to be cleaned when the batadv_orig_node is removed.
-
-Fixes: 21a57f6e7a3b ("batman-adv: make the TT CRC logic VLAN specific")
-Signed-off-by: Sven Eckelmann <sven@narfation.org>
-Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
-
-Origin: upstream, https://git.open-mesh.org/batman-adv.git/commit/719afd254e812c7ff8688ce79bebb7324ec438d6
----
- net/batman-adv/originator.c | 8 ++++++++
- 1 file changed, 8 insertions(+)
-
-diff --git a/net/batman-adv/originator.c b/net/batman-adv/originator.c
-index 28241a4..3a3948a 100644
---- a/net/batman-adv/originator.c
-+++ b/net/batman-adv/originator.c
-@@ -781,6 +781,7 @@ static void batadv_orig_node_release(struct kref *ref)
- 	struct batadv_neigh_node *neigh_node;
- 	struct batadv_orig_node *orig_node;
- 	struct batadv_orig_ifinfo *orig_ifinfo;
-+	struct batadv_orig_node_vlan *vlan;
- 
- 	orig_node = container_of(ref, struct batadv_orig_node, refcount);
- 
-@@ -800,6 +801,13 @@ static void batadv_orig_node_release(struct kref *ref)
- 	}
- 	spin_unlock_bh(&orig_node->neigh_list_lock);
- 
-+	spin_lock_bh(&orig_node->vlan_list_lock);
-+	hlist_for_each_entry_safe(vlan, node_tmp, &orig_node->vlan_list, list) {
-+		hlist_del_rcu(&vlan->list);
-+		batadv_orig_node_vlan_put(vlan);
-+	}
-+	spin_unlock_bh(&orig_node->vlan_list_lock);
-+
- 	/* Free nc_nodes */
- 	batadv_nc_purge_orig(orig_node->bat_priv, orig_node, NULL);
- 
diff --git a/batman-adv/patches/0019-batman-adv-Fix-non-atomic-bla_claim-backbone_gw-acce.patch b/batman-adv/patches/0019-batman-adv-Fix-non-atomic-bla_claim-backbone_gw-acce.patch
deleted file mode 100644
index 9631ebe..0000000
--- a/batman-adv/patches/0019-batman-adv-Fix-non-atomic-bla_claim-backbone_gw-acce.patch
+++ /dev/null
@@ -1,291 +0,0 @@
-From: Sven Eckelmann <sven@narfation.org>
-Date: Fri, 1 Jul 2016 15:49:43 +0200
-Subject: [PATCH] batman-adv: Fix non-atomic bla_claim::backbone_gw access
-
-The pointer batadv_bla_claim::backbone_gw can be changed at any time.
-Therefore, access to it must be protected to ensure that two function
-accessing the same backbone_gw are actually accessing the same. This is
-especially important when the crc_lock is used or when the backbone_gw of a
-claim is exchanged.
-
-Not doing so leads to invalid memory access and/or reference leaks.
-
-Fixes: a9ce0dc43e2c ("batman-adv: add basic bridge loop avoidance code")
-Fixes: b307e72d119f ("batman-adv: lock crc access in bridge loop avoidance")
-Signed-off-by: Sven Eckelmann <sven@narfation.org>
-Acked-by: Simon Wunderlich <sw@simonwunderlich.de>
-Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
-
-Origin: backport, https://git.open-mesh.org/batman-adv.git/commit/e401297e3a393896e9b07bef8d6e2df203b60d43
----
- net/batman-adv/bridge_loop_avoidance.c | 111 ++++++++++++++++++++++++++-------
- net/batman-adv/types.h                 |   2 +
- 2 files changed, 90 insertions(+), 23 deletions(-)
-
-diff --git a/net/batman-adv/bridge_loop_avoidance.c b/net/batman-adv/bridge_loop_avoidance.c
-index fe8b62f..30fd72e 100644
---- a/net/batman-adv/bridge_loop_avoidance.c
-+++ b/net/batman-adv/bridge_loop_avoidance.c
-@@ -176,10 +176,21 @@ static void batadv_backbone_gw_put(struct batadv_bla_backbone_gw *backbone_gw)
- static void batadv_claim_release(struct kref *ref)
- {
- 	struct batadv_bla_claim *claim;
-+	struct batadv_bla_backbone_gw *old_backbone_gw;
- 
- 	claim = container_of(ref, struct batadv_bla_claim, refcount);
- 
--	batadv_backbone_gw_put(claim->backbone_gw);
-+	spin_lock_bh(&claim->backbone_lock);
-+	old_backbone_gw = claim->backbone_gw;
-+	claim->backbone_gw = NULL;
-+	spin_unlock_bh(&claim->backbone_lock);
-+
-+	spin_lock_bh(&old_backbone_gw->crc_lock);
-+	old_backbone_gw->crc ^= crc16(0, claim->addr, ETH_ALEN);
-+	spin_unlock_bh(&old_backbone_gw->crc_lock);
-+
-+	batadv_backbone_gw_put(old_backbone_gw);
-+
- 	kfree_rcu(claim, rcu);
- }
- 
-@@ -637,8 +648,10 @@ static void batadv_bla_add_claim(struct batadv_priv *bat_priv,
- 				 const u8 *mac, const unsigned short vid,
- 				 struct batadv_bla_backbone_gw *backbone_gw)
- {
-+	struct batadv_bla_backbone_gw *old_backbone_gw;
- 	struct batadv_bla_claim *claim;
- 	struct batadv_bla_claim search_claim;
-+	bool remove_crc = false;
- 	int hash_added;
- 
- 	ether_addr_copy(search_claim.addr, mac);
-@@ -652,8 +665,10 @@ static void batadv_bla_add_claim(struct batadv_priv *bat_priv,
- 			return;
- 
- 		ether_addr_copy(claim->addr, mac);
-+		spin_lock_init(&claim->backbone_lock);
- 		claim->vid = vid;
- 		claim->lasttime = jiffies;
-+		kref_get(&backbone_gw->refcount);
- 		claim->backbone_gw = backbone_gw;
- 
- 		kref_init(&claim->refcount);
-@@ -681,15 +696,26 @@ static void batadv_bla_add_claim(struct batadv_priv *bat_priv,
- 			   "bla_add_claim(): changing ownership for %pM, vid %d\n",
- 			   mac, BATADV_PRINT_VID(vid));
- 
--		spin_lock_bh(&claim->backbone_gw->crc_lock);
--		claim->backbone_gw->crc ^= crc16(0, claim->addr, ETH_ALEN);
--		spin_unlock_bh(&claim->backbone_gw->crc_lock);
--		batadv_backbone_gw_put(claim->backbone_gw);
-+		remove_crc = true;
- 	}
--	/* set (new) backbone gw */
-+
-+	/* replace backbone_gw atomically and adjust reference counters */
-+	spin_lock_bh(&claim->backbone_lock);
-+	old_backbone_gw = claim->backbone_gw;
- 	kref_get(&backbone_gw->refcount);
- 	claim->backbone_gw = backbone_gw;
-+	spin_unlock_bh(&claim->backbone_lock);
- 
-+	if (remove_crc) {
-+		/* remove claim address from old backbone_gw */
-+		spin_lock_bh(&old_backbone_gw->crc_lock);
-+		old_backbone_gw->crc ^= crc16(0, claim->addr, ETH_ALEN);
-+		spin_unlock_bh(&old_backbone_gw->crc_lock);
-+	}
-+
-+	batadv_backbone_gw_put(old_backbone_gw);
-+
-+	/* add claim address to new backbone_gw */
- 	spin_lock_bh(&backbone_gw->crc_lock);
- 	backbone_gw->crc ^= crc16(0, claim->addr, ETH_ALEN);
- 	spin_unlock_bh(&backbone_gw->crc_lock);
-@@ -700,6 +726,26 @@ claim_free_ref:
- }
- 
- /**
-+ * batadv_bla_claim_get_backbone_gw - Get valid reference for backbone_gw of
-+ *  claim
-+ * @claim: claim whose backbone_gw should be returned
-+ *
-+ * Return: valid reference to claim::backbone_gw
-+ */
-+static struct batadv_bla_backbone_gw *
-+batadv_bla_claim_get_backbone_gw(struct batadv_bla_claim *claim)
-+{
-+	struct batadv_bla_backbone_gw *backbone_gw;
-+
-+	spin_lock_bh(&claim->backbone_lock);
-+	backbone_gw = claim->backbone_gw;
-+	kref_get(&backbone_gw->refcount);
-+	spin_unlock_bh(&claim->backbone_lock);
-+
-+	return backbone_gw;
-+}
-+
-+/**
-  * batadv_bla_del_claim - delete a claim from the claim hash
-  * @bat_priv: the bat priv with all the soft interface information
-  * @mac: mac address of the claim to be removed
-@@ -723,10 +769,6 @@ static void batadv_bla_del_claim(struct batadv_priv *bat_priv,
- 			   batadv_choose_claim, claim);
- 	batadv_claim_put(claim); /* reference from the hash is gone */
- 
--	spin_lock_bh(&claim->backbone_gw->crc_lock);
--	claim->backbone_gw->crc ^= crc16(0, claim->addr, ETH_ALEN);
--	spin_unlock_bh(&claim->backbone_gw->crc_lock);
--
- 	/* don't need the reference from hash_find() anymore */
- 	batadv_claim_put(claim);
- }
-@@ -1175,6 +1217,7 @@ static void batadv_bla_purge_claims(struct batadv_priv *bat_priv,
- 				    struct batadv_hard_iface *primary_if,
- 				    int now)
- {
-+	struct batadv_bla_backbone_gw *backbone_gw;
- 	struct batadv_bla_claim *claim;
- 	struct hlist_head *head;
- 	struct batadv_hashtable *hash;
-@@ -1189,14 +1232,17 @@ static void batadv_bla_purge_claims(struct batadv_priv *bat_priv,
- 
- 		rcu_read_lock();
- 		hlist_for_each_entry_rcu(claim, head, hash_entry) {
-+			backbone_gw = batadv_bla_claim_get_backbone_gw(claim);
- 			if (now)
- 				goto purge_now;
--			if (!batadv_compare_eth(claim->backbone_gw->orig,
-+
-+			if (!batadv_compare_eth(backbone_gw->orig,
- 						primary_if->net_dev->dev_addr))
--				continue;
-+				goto skip;
-+
- 			if (!batadv_has_timed_out(claim->lasttime,
- 						  BATADV_BLA_CLAIM_TIMEOUT))
--				continue;
-+				goto skip;
- 
- 			batadv_dbg(BATADV_DBG_BLA, bat_priv,
- 				   "bla_purge_claims(): %pM, vid %d, time out\n",
-@@ -1204,8 +1250,10 @@ static void batadv_bla_purge_claims(struct batadv_priv *bat_priv,
- 
- purge_now:
- 			batadv_handle_unclaim(bat_priv, primary_if,
--					      claim->backbone_gw->orig,
-+					      backbone_gw->orig,
- 					      claim->addr, claim->vid);
-+skip:
-+			batadv_backbone_gw_put(backbone_gw);
- 		}
- 		rcu_read_unlock();
- 	}
-@@ -1623,9 +1671,11 @@ void batadv_bla_free(struct batadv_priv *bat_priv)
- int batadv_bla_rx(struct batadv_priv *bat_priv, struct sk_buff *skb,
- 		  unsigned short vid, bool is_bcast)
- {
-+	struct batadv_bla_backbone_gw *backbone_gw;
- 	struct ethhdr *ethhdr;
- 	struct batadv_bla_claim search_claim, *claim = NULL;
- 	struct batadv_hard_iface *primary_if;
-+	bool own_claim;
- 	int ret;
- 
- 	ethhdr = eth_hdr(skb);
-@@ -1657,8 +1707,12 @@ int batadv_bla_rx(struct batadv_priv *bat_priv, struct sk_buff *skb,
- 	}
- 
- 	/* if it is our own claim ... */
--	if (batadv_compare_eth(claim->backbone_gw->orig,
--			       primary_if->net_dev->dev_addr)) {
-+	backbone_gw = batadv_bla_claim_get_backbone_gw(claim);
-+	own_claim = batadv_compare_eth(backbone_gw->orig,
-+				       primary_if->net_dev->dev_addr);
-+	batadv_backbone_gw_put(backbone_gw);
-+
-+	if (own_claim) {
- 		/* ... allow it in any case */
- 		claim->lasttime = jiffies;
- 		goto allow;
-@@ -1722,7 +1776,9 @@ int batadv_bla_tx(struct batadv_priv *bat_priv, struct sk_buff *skb,
- {
- 	struct ethhdr *ethhdr;
- 	struct batadv_bla_claim search_claim, *claim = NULL;
-+	struct batadv_bla_backbone_gw *backbone_gw;
- 	struct batadv_hard_iface *primary_if;
-+	bool client_roamed;
- 	int ret = 0;
- 
- 	primary_if = batadv_primary_if_get_selected(bat_priv);
-@@ -1752,8 +1808,12 @@ int batadv_bla_tx(struct batadv_priv *bat_priv, struct sk_buff *skb,
- 		goto allow;
- 
- 	/* check if we are responsible. */
--	if (batadv_compare_eth(claim->backbone_gw->orig,
--			       primary_if->net_dev->dev_addr)) {
-+	backbone_gw = batadv_bla_claim_get_backbone_gw(claim);
-+	client_roamed = batadv_compare_eth(backbone_gw->orig,
-+					   primary_if->net_dev->dev_addr);
-+	batadv_backbone_gw_put(backbone_gw);
-+
-+	if (client_roamed) {
- 		/* if yes, the client has roamed and we have
- 		 * to unclaim it.
- 		 */
-@@ -1801,6 +1861,7 @@ int batadv_bla_claim_table_seq_print_text(struct seq_file *seq, void *offset)
- 	struct net_device *net_dev = (struct net_device *)seq->private;
- 	struct batadv_priv *bat_priv = netdev_priv(net_dev);
- 	struct batadv_hashtable *hash = bat_priv->bla.claim_hash;
-+	struct batadv_bla_backbone_gw *backbone_gw;
- 	struct batadv_bla_claim *claim;
- 	struct batadv_hard_iface *primary_if;
- 	struct hlist_head *head;
-@@ -1825,17 +1886,21 @@ int batadv_bla_claim_table_seq_print_text(struct seq_file *seq, void *offset)
- 
- 		rcu_read_lock();
- 		hlist_for_each_entry_rcu(claim, head, hash_entry) {
--			is_own = batadv_compare_eth(claim->backbone_gw->orig,
-+			backbone_gw = batadv_bla_claim_get_backbone_gw(claim);
-+
-+			is_own = batadv_compare_eth(backbone_gw->orig,
- 						    primary_addr);
- 
--			spin_lock_bh(&claim->backbone_gw->crc_lock);
--			backbone_crc = claim->backbone_gw->crc;
--			spin_unlock_bh(&claim->backbone_gw->crc_lock);
-+			spin_lock_bh(&backbone_gw->crc_lock);
-+			backbone_crc = backbone_gw->crc;
-+			spin_unlock_bh(&backbone_gw->crc_lock);
- 			seq_printf(seq, " * %pM on %5d by %pM [%c] (%#.4x)\n",
- 				   claim->addr, BATADV_PRINT_VID(claim->vid),
--				   claim->backbone_gw->orig,
-+				   backbone_gw->orig,
- 				   (is_own ? 'x' : ' '),
- 				   backbone_crc);
-+
-+			batadv_backbone_gw_put(backbone_gw);
- 		}
- 		rcu_read_unlock();
- 	}
-diff --git a/net/batman-adv/types.h b/net/batman-adv/types.h
-index d75beef..41a85b5 100644
---- a/net/batman-adv/types.h
-+++ b/net/batman-adv/types.h
-@@ -1034,6 +1034,7 @@ struct batadv_bla_backbone_gw {
-  * @addr: mac address of claimed non-mesh client
-  * @vid: vlan id this client was detected on
-  * @backbone_gw: pointer to backbone gw claiming this client
-+ * @backbone_lock: lock protecting backbone_gw pointer
-  * @lasttime: last time we heard of claim (locals only)
-  * @hash_entry: hlist node for batadv_priv_bla::claim_hash
-  * @refcount: number of contexts the object is used
-@@ -1043,6 +1044,7 @@ struct batadv_bla_claim {
- 	u8 addr[ETH_ALEN];
- 	unsigned short vid;
- 	struct batadv_bla_backbone_gw *backbone_gw;
-+	spinlock_t backbone_lock; /* protects backbone_gw */
- 	unsigned long lasttime;
- 	struct hlist_node hash_entry;
- 	struct rcu_head rcu;
diff --git a/batman-adv/patches/0020-batman-adv-Fix-reference-leak-in-batadv_find_router.patch b/batman-adv/patches/0020-batman-adv-Fix-reference-leak-in-batadv_find_router.patch
deleted file mode 100644
index 38956cf..0000000
--- a/batman-adv/patches/0020-batman-adv-Fix-reference-leak-in-batadv_find_router.patch
+++ /dev/null
@@ -1,120 +0,0 @@
-From: Sven Eckelmann <sven@narfation.org>
-Date: Thu, 30 Jun 2016 20:11:34 +0200
-Subject: [PATCH] batman-adv: Fix reference leak in batadv_find_router
-
-The replacement of last_bonding_candidate in batadv_orig_node has to be an
-atomic operation. Otherwise it is possible that the reference counter of a
-batadv_orig_ifinfo is reduced which was no longer the
-last_bonding_candidate when the new candidate is added. This can either
-lead to an invalid memory access or to reference leaks which make it
-impossible to an interface which was added to batman-adv.
-
-Fixes: 797edd9e87ac ("batman-adv: add bonding again")
-Signed-off-by: Sven Eckelmann <sven@narfation.org>
-Acked-by: Simon Wunderlich <sw@simonwunderlich.de>
-Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
-
-Origin: upstream, https://git.open-mesh.org/batman-adv.git/commit/6ecc711374afd93ee0c2216b38ae52d3ce680c3f
----
- net/batman-adv/routing.c | 52 ++++++++++++++++++++++++++++++++++++------------
- net/batman-adv/types.h   |  4 +++-
- 2 files changed, 42 insertions(+), 14 deletions(-)
-
-diff --git a/net/batman-adv/routing.c b/net/batman-adv/routing.c
-index 27e07dd..694dc74 100644
---- a/net/batman-adv/routing.c
-+++ b/net/batman-adv/routing.c
-@@ -456,6 +456,29 @@ static int batadv_check_unicast_packet(struct batadv_priv *bat_priv,
- }
- 
- /**
-+ * batadv_last_bonding_replace - Replace last_bonding_candidate of orig_node
-+ * @orig_node: originator node whose bonding candidates should be replaced
-+ * @new_candidate: new bonding candidate or NULL
-+ */
-+static void
-+batadv_last_bonding_replace(struct batadv_orig_node *orig_node,
-+			    struct batadv_orig_ifinfo *new_candidate)
-+{
-+	struct batadv_orig_ifinfo *old_candidate;
-+
-+	spin_lock_bh(&orig_node->neigh_list_lock);
-+	old_candidate = orig_node->last_bonding_candidate;
-+
-+	if (new_candidate)
-+		kref_get(&new_candidate->refcount);
-+	orig_node->last_bonding_candidate = new_candidate;
-+	spin_unlock_bh(&orig_node->neigh_list_lock);
-+
-+	if (old_candidate)
-+		batadv_orig_ifinfo_put(old_candidate);
-+}
-+
-+/**
-  * batadv_find_router - find a suitable router for this originator
-  * @bat_priv: the bat priv with all the soft interface information
-  * @orig_node: the destination node
-@@ -562,10 +585,6 @@ next:
- 	}
- 	rcu_read_unlock();
- 
--	/* last_bonding_candidate is reset below, remove the old reference. */
--	if (orig_node->last_bonding_candidate)
--		batadv_orig_ifinfo_put(orig_node->last_bonding_candidate);
--
- 	/* After finding candidates, handle the three cases:
- 	 * 1) there is a next candidate, use that
- 	 * 2) there is no next candidate, use the first of the list
-@@ -574,21 +593,28 @@ next:
- 	if (next_candidate) {
- 		batadv_neigh_node_put(router);
- 
--		/* remove references to first candidate, we don't need it. */
--		if (first_candidate) {
--			batadv_neigh_node_put(first_candidate_router);
--			batadv_orig_ifinfo_put(first_candidate);
--		}
-+		kref_get(&next_candidate_router->refcount);
- 		router = next_candidate_router;
--		orig_node->last_bonding_candidate = next_candidate;
-+		batadv_last_bonding_replace(orig_node, next_candidate);
- 	} else if (first_candidate) {
- 		batadv_neigh_node_put(router);
- 
--		/* refcounting has already been done in the loop above. */
-+		kref_get(&first_candidate_router->refcount);
- 		router = first_candidate_router;
--		orig_node->last_bonding_candidate = first_candidate;
-+		batadv_last_bonding_replace(orig_node, first_candidate);
- 	} else {
--		orig_node->last_bonding_candidate = NULL;
-+		batadv_last_bonding_replace(orig_node, NULL);
-+	}
-+
-+	/* cleanup of candidates */
-+	if (first_candidate) {
-+		batadv_neigh_node_put(first_candidate_router);
-+		batadv_orig_ifinfo_put(first_candidate);
-+	}
-+
-+	if (next_candidate) {
-+		batadv_neigh_node_put(next_candidate_router);
-+		batadv_orig_ifinfo_put(next_candidate);
- 	}
- 
- 	return router;
-diff --git a/net/batman-adv/types.h b/net/batman-adv/types.h
-index 41a85b5..c143649 100644
---- a/net/batman-adv/types.h
-+++ b/net/batman-adv/types.h
-@@ -330,7 +330,9 @@ struct batadv_orig_node {
- 	DECLARE_BITMAP(bcast_bits, BATADV_TQ_LOCAL_WINDOW_SIZE);
- 	u32 last_bcast_seqno;
- 	struct hlist_head neigh_list;
--	/* neigh_list_lock protects: neigh_list and router */
-+	/* neigh_list_lock protects: neigh_list, ifinfo_list,
-+	 * last_bonding_candidate and router
-+	 */
- 	spinlock_t neigh_list_lock;
- 	struct hlist_node hash_entry;
- 	struct batadv_priv *bat_priv;
diff --git a/batman-adv/patches/0021-batman-adv-Free-last_bonding_candidate-on-release-of.patch b/batman-adv/patches/0021-batman-adv-Free-last_bonding_candidate-on-release-of.patch
deleted file mode 100644
index b35a801..0000000
--- a/batman-adv/patches/0021-batman-adv-Free-last_bonding_candidate-on-release-of.patch
+++ /dev/null
@@ -1,45 +0,0 @@
-From: Sven Eckelmann <sven@narfation.org>
-Date: Thu, 30 Jun 2016 21:41:13 +0200
-Subject: [PATCH] batman-adv: Free last_bonding_candidate on release of orig_node
-
-The orig_ifinfo reference counter for last_bonding_candidate in
-batadv_orig_node has to be reduced when an originator node is released.
-Otherwise the orig_ifinfo is leaked and the reference counter the netdevice
-is not reduced correctly.
-
-Fixes: 797edd9e87ac ("batman-adv: add bonding again")
-Signed-off-by: Sven Eckelmann <sven@narfation.org>
-Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
-
-Origin: upstream, https://git.open-mesh.org/batman-adv.git/commit/20df5c53865a90095099f0af80536b8abfea303b
----
- net/batman-adv/originator.c | 7 +++++++
- 1 file changed, 7 insertions(+)
-
-diff --git a/net/batman-adv/originator.c b/net/batman-adv/originator.c
-index 3a3948a..7594afd 100644
---- a/net/batman-adv/originator.c
-+++ b/net/batman-adv/originator.c
-@@ -782,6 +782,7 @@ static void batadv_orig_node_release(struct kref *ref)
- 	struct batadv_orig_node *orig_node;
- 	struct batadv_orig_ifinfo *orig_ifinfo;
- 	struct batadv_orig_node_vlan *vlan;
-+	struct batadv_orig_ifinfo *last_candidate;
- 
- 	orig_node = container_of(ref, struct batadv_orig_node, refcount);
- 
-@@ -799,8 +800,14 @@ static void batadv_orig_node_release(struct kref *ref)
- 		hlist_del_rcu(&orig_ifinfo->list);
- 		batadv_orig_ifinfo_put(orig_ifinfo);
- 	}
-+
-+	last_candidate = orig_node->last_bonding_candidate;
-+	orig_node->last_bonding_candidate = NULL;
- 	spin_unlock_bh(&orig_node->neigh_list_lock);
- 
-+	if (last_candidate)
-+		batadv_orig_ifinfo_put(last_candidate);
-+
- 	spin_lock_bh(&orig_node->vlan_list_lock);
- 	hlist_for_each_entry_safe(vlan, node_tmp, &orig_node->vlan_list, list) {
- 		hlist_del_rcu(&vlan->list);
diff --git a/batman-adv/patches/0022-batman-adv-Fix-speedy-join-in-gateway-client-mode.patch b/batman-adv/patches/0022-batman-adv-Fix-speedy-join-in-gateway-client-mode.patch
deleted file mode 100644
index fa61a1b..0000000
--- a/batman-adv/patches/0022-batman-adv-Fix-speedy-join-in-gateway-client-mode.patch
+++ /dev/null
@@ -1,35 +0,0 @@
-From: Sven Eckelmann <sven@narfation.org>
-Date: Sun, 12 Jun 2016 10:43:19 +0200
-Subject: [PATCH] batman-adv: Fix speedy join in gateway client mode
-
-Speedy join only works when the received packet is either broadcast or an
-4addr unicast packet. Thus packets converted from broadcast to unicast via
-the gateway handling code have to be converted to 4addr packets to allow
-the receiving gateway server to add the sender address as temporary entry
-to the translation table.
-
-Not doing it will make the batman-adv gateway server drop the DHCP response
-in many situations because it doesn't yet have the TT entry for the
-destination of the DHCP response.
-
-Fixes: 9cbc67d9da47 ("batman-adv: change interface_rx to get orig node")
-Signed-off-by: Sven Eckelmann <sven@narfation.org>
----
- net/batman-adv/send.c | 4 ++--
- 1 file changed, 2 insertions(+), 2 deletions(-)
-
-diff --git a/net/batman-adv/send.c b/net/batman-adv/send.c
-index 7641785..e5be212 100644
---- a/net/batman-adv/send.c
-+++ b/net/batman-adv/send.c
-@@ -423,8 +423,8 @@ int batadv_send_skb_via_gw(struct batadv_priv *bat_priv, struct sk_buff *skb,
- 	struct batadv_orig_node *orig_node;
- 
- 	orig_node = batadv_gw_get_selected_orig(bat_priv);
--	return batadv_send_skb_unicast(bat_priv, skb, BATADV_UNICAST, 0,
--				       orig_node, vid);
-+	return batadv_send_skb_unicast(bat_priv, skb, BATADV_UNICAST_4ADDR,
-+				       BATADV_P_DATA, orig_node, vid);
- }
- 
- void batadv_schedule_bat_ogm(struct batadv_hard_iface *hard_iface)
-- 
2.10.2

